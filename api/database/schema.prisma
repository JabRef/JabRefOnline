// After changing this file, run yarn prisma:migrate:dev to push the changes to the database

datasource db {
  provider = "postgresql"
  url = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  // Enable cascading deletes and updates
  previewFeatures = ["referentialActions"]
}

model User {
  id String @id @default(cuid())
  email String @unique
  emailIsVerified Boolean @default(false)
  name String?
  password String
  createdAt DateTime @default(now())
  documents UserDocument[]
  groups Group[]
}

enum DocumentType {
  JOURNAL_ARTICLE
  PROCEEDINGS_ARTICLE
  THESIS
  OTHER
}

// Articles, books etc added by users
// We do not know what users put in their fields, thus we assume everything is a string
model UserDocument {
  id String @id @default(cuid())
  users User[]

  type DocumentType
  citationKeys String[]

  lastModified DateTime?
  added DateTime?

  // Common fields
  author String?
  editor String?
  title String?

  // Type-specific
  journalIssue JournalIssue? @relation(fields: [journalIssueId], references: [id])
  journalIssueId String?
  
  booktitle String?
  publishedAt String? // format: YYYY(-MM-DD) TODO: Should use Date format once https://github.com/prisma/prisma/issues/4355 is resolved
  edition String?
  pageStart String?
  pageEnd String?
  pagetotal String?
  note String?
  url String?
  urldate String?
  publisher String?
  abstract String?
  keywords String[]

  // JabRef-specific
  explicitGroups Group[]
  priority String?

  // Identifier
  doi String?
  eprint String?
  eprintclass String?
  eprinttype String?
  isbn String?

  // Other fields that are not often used
  other UserDocumentOtherField[]
}

model JournalIssue {
  id String @id @default(cuid())
  articles UserDocument[]
  journal Journal? @relation(fields: [journalId], references: [id])
  journalId String?
  title String?
  subtitle String?
  titleAddon String?
  number String?
  name String?
  series String?
  volume String?
}

model Journal {
  id String @id @default(cuid())
  issues JournalIssue[]
  name String
  subtitle String?
  titleAddon String?
  issn String?
}

model UserDocumentOtherField {
  document UserDocument @relation(fields: [documentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  documentId String
  field String
  value String

  @@id([documentId, field])
}

enum GroupHierarchyType {
  /// The group's content is independent of its hierarchical position.
  INDEPENDENT

  /// The group's content is the intersection of its own content with its supergroups' content.
  INTERSECTION

  /// The group's content is the union of its own content with its subgroups' content.
  UNION
}

enum GroupType {
  AutomaticKeywordGroup
  AutomaticPersonsGroup
  ExplicitGroup
  LastNameGroup
  WordKeywordGroup
  RegexKeywordGroup
  SearchGroup
  TexGroup
}

model Group {
  id String @id @default(cuid())
  users User[]
  name String
  displayName String
  parentId String?
  parent Group? @relation("GroupTree", fields: [parentId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  children Group[] @relation("GroupTree")

  hierarchyType GroupHierarchyType
  color String?
  description String?
  icon String?
  isExpanded Boolean

  // Prisma currently does not support union types / inheritance (https://github.com/prisma/prisma/issues/2505)
  // Thus, we assemble all possible fields from all types of groups here
  type GroupType
  explicitDocuments UserDocument[]
  field String?
  keywordDelimiter String?
  keywordHierarchicalDelimiter String?
  authorLastName String?
  searchExpression String?
  caseSensitive Boolean?
  onlySplitWordsAtDelimiter Boolean?
  isRegEx Boolean?
}
